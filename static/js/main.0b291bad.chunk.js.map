{"version":3,"sources":["serviceWorker.js","sudoku/Grid.js","sudoku/CellState.js","sudoku/gridReducer.js","sudoku/GridState.js","sudoku/Context.js","sudoku/DebugGrid.js","sudoku/PuzzleGrid.js","sudoku/Sudoku.js","index.js"],"names":["Boolean","window","location","hostname","match","Grid","props","span","className","HeaderRow","Row","row","cells","GRID_INDEXES","SEGMENT_TYPES","REGION_INDEXES","map","i","scope","rowLabel","charAt","rowStartIdx","col","cellIdx","AVAILABLE_VALUES","CellState","index","value","readOnly","errors","availableValues","this","Error","undefined","column","region","total","isNaN","Set","Object","freeze","Math","trunc","regionRow","regionColumn","segmentType","clear","add","values","delete","SetValueAction","gridReducer","grid","action","constructor","newGrid","GridState","oldCell","newCell","cellReducer","segmentIndex","segment","usedValues","removeAvailableValues","relatedCell","cell","segmentType1","isValueAvailable","addAvailableValue","eliminateAvailableValues","valueCells","filter","length","clearError","clearCellValue","has","setError","setCellValue","cellsByAvailableValue","setAvailableValue","type","_emptyGrid","flatMap","NaN","gridString","split","val","idx","parseInt","rowIndex","startIdx","offset","SegmentState","columnIndex","regionIndex","regionCol","rowOffset","colOffset","_parseGrid","_cellsByAvailableValue","reduce","acc","set","get","push","Map","DispatchContext","React","createContext","GridContext","DebugGrid","DebugCell","useContext","size","Array","from","sort","join","PuzzleGrid","Cell","dispatch","min","max","maxLength","onChange","event","target","valueAsNumber","Sudoku","useReducer","newFrom","Provider","ReactDOM","render","StrictMode","href","rel","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"2MAYoBA,QACa,cAA7BC,OAAOC,SAASC,UAEa,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACrB,2D,uCClBO,SAASC,EAAKC,GACzB,OACI,kCACI,0BAAUC,KAAK,MACf,0BAAUC,UAAU,SAASD,KAAK,MAClC,0BAAUC,UAAU,SAASD,KAAK,MAClC,0BAAUC,UAAU,SAASD,KAAK,MAElC,cAACE,EAAD,IACA,wBAAOD,UAAU,SAAjB,UACA,cAACE,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,QAC1B,cAACF,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,QAC1B,cAACF,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,WAE1B,wBAAOJ,UAAU,SAAjB,UACA,cAACE,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,QAC1B,cAACF,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,QAC1B,cAACF,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,WAE1B,wBAAOJ,UAAU,SAAjB,UACA,cAACE,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,QAC1B,cAACF,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,QAC1B,cAACF,EAAD,CAAKC,IAAK,EAAGC,MAAON,EAAMM,cAM/B,IACMC,EAAe,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACxCC,EAAgB,CAAC,MAAO,SAAU,UAElCC,EAAiB,CAAC,EAAG,EAAG,GAErC,SAASN,IACL,OACI,gCACA,+BACI,uBACCI,EAAaG,KAAI,SAACC,GAAD,OACd,oBAAIC,MAAM,MAAV,SAAyBD,GAAJA,WAOrC,SAASP,EAAIJ,GACT,IAAMa,EAAW,YAAYC,OAAOd,EAAMK,KACpCU,EArBe,EAqBDf,EAAMK,IAC1B,OACI,+BACI,oBAAIO,MAAM,MAAV,SAAiBC,IAChBN,EAAaG,KAAI,SAACM,GACf,IAAMC,EAAUF,EAAcC,EAC9B,OAAOhB,EAAMM,MAAMW,SCrDnC,IAAMC,EAAmB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAE7BC,E,WACjB,WAAYC,EAAOC,EAAOC,EAAUC,EAAQC,GAIxC,GAJ0D,oBAC1DC,KAAKL,MAAQA,EACbK,KAAKJ,MAAQA,EAETC,GAEA,GADAG,KAAKH,UAAW,EACZC,GAAUC,EACV,MAAM,IAAIE,MAAJ,kEAAqEH,EAArE,eAAkFC,SAG5FC,KAAKF,YAAoBI,IAAXJ,EAAuBA,EAAS,CAAClB,IAAK,EAAGuB,OAAQ,EAAGC,OAAQ,EAAGC,MAAO,GAChFC,MAAMN,KAAKJ,OACXI,KAAKD,gBAAkBA,GAAmB,IAAIQ,IAAId,GAElDO,KAAKD,gBAAkB,IAAIQ,IAMnCC,OAAOC,OAAOT,M,qCAGlB,WACI,OAAOU,KAAKC,MAAMX,KAAKL,MDDN,K,kBCIrB,WACI,OAAOK,KAAKL,MDLK,I,qBCQrB,WACI,OAAOe,KAAKC,MAAMX,KAAKpB,IDNJ,K,wBCSvB,WACI,OAAO8B,KAAKC,MAAMX,KAAKG,ODVJ,K,kBCavB,WACI,ODdmB,ECcXH,KAAKY,UAA2BZ,KAAKa,e,sBAGjD,SAASC,GACL,GAAId,KAAKF,OAAOgB,GACZ,MAAM,IAAIb,MAAJ,sDAAyDa,IAEnEd,KAAKF,OAAOgB,GAAe,EAC3Bd,KAAKF,OAAOO,OAAS,I,wBAGzB,SAAWS,GACP,IAAKd,KAAKF,OAAOgB,GACb,MAAM,IAAIb,MAAJ,4CAA+Ca,IAEzDd,KAAKF,OAAOgB,GAAe,EAC3Bd,KAAKF,OAAOO,OAAS,I,+BAGzB,SAAkBT,GACdI,KAAKD,gBAAgBgB,QACrBf,KAAKD,gBAAgBiB,IAAIpB,K,+BAG7B,SAAkBA,GACdI,KAAKD,gBAAgBiB,IAAIpB,K,mCAG7B,SAAsBqB,GAAS,IAAD,gBACNA,GADM,IAC1B,2BAA4B,CAAC,IAAlBrB,EAAiB,QACxBI,KAAKD,gBAAgBmB,OAAOtB,IAFN,mC,YCrE3B,SAASuB,EAAexB,EAAOC,EAAOC,GACzCG,KAAKL,MAAQA,EACbK,KAAKJ,MAAQA,EACbI,KAAKH,SAAWA,IAAY,EAGzB,SAASuB,EAAYC,EAAMC,GAC9B,GAAIA,EAAOC,cAAgBJ,EACvB,MAAM,IAAIlB,MAAJ,yBAA4BqB,IAItC,OAAIA,EAAO1B,MAAQ,GAAK0B,EAAO1B,MAAQ,EAC5ByB,EAGNf,MAAMgB,EAAO1B,OA0CtB,SAAwByB,EAAMC,GAE1B,IAFkC,EAE5BzC,EAAK,YAAOwC,EAAKxC,OACjB2C,EAAU,IAAIC,EAAU5C,GAGxB6C,EAAU7C,EAAMyC,EAAO3B,OACvBgC,EAAU9C,EAAMyC,EAAO3B,OAASiC,EAAYF,EAASJ,GAPzB,cASRvC,GATQ,IASlC,2BAAyC,CAAC,IAA/B+B,EAA8B,QAC/Be,EAAeF,EAAQb,GACvBgB,EAAUN,EAAQM,QAAQhB,EAAae,GAGvCE,EAAaD,EAAQb,OAC3BU,EAAQK,sBAAsBD,GANO,oBASdD,EAAQjD,OATM,IAQrCoD,EACI,2BAAkC,CAAC,IAAxBC,EAAuB,QAC9B,IAAIA,EAAKrC,SAAT,CAD8B,oBAIHd,GAJG,IAI9B,2BAA0C,CAAC,IAAhCoD,EAA+B,QAEtC,IADiBX,EAAQM,QAAQK,EAAcD,EAAKC,IACtCC,iBAAiBV,EAAQ9B,OACnC,SAASqC,GAPa,8BAU9BC,EAAKG,kBAAkBX,EAAQ9B,SAnBF,8BAqBrC0C,EAAyBR,GAGzB,IAAMS,EAAaT,EAAQjD,MACtB2D,QAAO,SAACN,GAAD,OAAUA,EAAKtC,QAAU8B,EAAQ9B,SAC7C,GAA0B,IAAtB2C,EAAWE,OAAc,qBACNF,GADM,IACzB,2BAA+B,CAAC,IAArBL,EAAoB,SACtBA,EAAKrC,UAAYqC,EAAKpC,OAAOgB,IAC9BoB,EAAKQ,WAAW5B,IAHC,iCAnCC,8BA2ClC,OAAO,IAAIW,EAAU5C,GAlFV8D,CAAetB,EAAMC,GAIpC,SAAsBD,EAAMC,GAExB,IAFgC,EAE1BzC,EAAK,YAAOwC,EAAKxC,OACjB2C,EAAU,IAAIC,EAAU5C,GAGxB6C,EAAU7C,EAAMyC,EAAO3B,OACvBgC,EAAU9C,EAAMyC,EAAO3B,OAASiC,EAAYF,EAASJ,GAP3B,cASNvC,GATM,IAShC,2BAAyC,CAAC,IAAD,EAA9B+B,EAA8B,QAC/Be,EAAeF,EAAQb,GACvBgB,EAAUN,EAAQM,QAAQhB,EAAae,GAFR,cAKlBC,EAAQjD,OALU,IAKrC,2BAAkC,CAAC,IAAxBqD,EAAuB,QAC1B5B,MAAM4B,EAAKtC,QAAUsC,EAAKnC,gBAAgB6C,IAAItB,EAAO1B,QACrDsC,EAAKF,sBAAsB,CAACV,EAAO1B,SAPN,8BAUrC0C,EAAyBR,GAGzB,IAAMS,EAAaT,EAAQjD,MACtB2D,QAAO,SAACN,GAAD,OAAUA,EAAKtC,QAAU0B,EAAO1B,SAC5C,GAAI2C,EAAWE,OAAS,EAAG,CAAC,IAAD,gBACJF,GADI,IACvB,2BAA+B,CAAC,IAArBL,EAAoB,QACtBA,EAAKrC,UAAaqC,EAAKpC,OAAOgB,IAC/BoB,EAAKW,SAAS/B,IAHC,iCAxBC,8BAgChC,OAAOU,EAtCIsB,CAAazB,EAAMC,GAuFlC,SAASgB,EAAyBR,GAAS,oBAEVA,EAAQiB,uBAFE,IAEvC,2BAA4D,CAAC,IAAD,yBAAhDnD,EAAgD,KAAzCf,EAAyC,KACnC,IAAjBA,EAAM4D,QACN5D,EAAM,GAAGmE,kBAAkBpD,IAJI,+BAS3C,SAASgC,EAAYM,EAAMZ,GAEvB,GAAIY,EAAKrC,SACL,MAAM,IAAII,MAAJ,4CAA+CiC,EAAKvC,QAG9D,GAAI2B,EAAOC,cAAgBJ,EAAgB,CACvC,IAAMtB,EAAWyB,EAAOzB,SAClBC,EAAUD,GAAaS,MAAMgB,EAAO1B,YAAuBM,EAAdgC,EAAKpC,OACxD,OAAO,IAAIJ,EAAU4B,EAAO3B,MAAO2B,EAAO1B,MAAOC,EAAUC,GAG3D,MAAM,IAAIG,MAAJ,8BAAiCqB,EAAO2B,O,IC7HjCxB,E,WACjB,WAAY5C,GAOR,GAPgB,oBAIZmB,KAAKnB,MAHJA,GACYmB,KAAKkD,aAKlBlD,KAAKnB,MAAM4D,SAAX,SHgBa,EGhBsB,GACnC,MAAM,IAAIxC,MAAJ,0CAA6CpB,EAAM4D,SAI7DjC,OAAOC,OAAOT,M,8CAelB,WACI,IAAId,EAAI,EACR,OAAOJ,EAAaqE,SAAQ,kBACxBrE,EAAaG,KAAI,kBACb,IAAIS,EAAUR,IAAKkE,a,wBAK/B,SAAWC,GAEP,OADgBA,EAAYC,MAAM,IACpBrE,KAAI,SAACsE,EAAKC,GAMpB,OAJID,GADCA,GAAOA,EAAM,EACRH,IAEAK,SAASF,GAEZ,IAAI7D,EAAU8D,EAAKD,GAAMjD,MAAMiD,S,iBAI9C,SAAIG,GAAW,IAAD,OACJC,EH1BW,EG0BAD,EACX7E,EAAQC,EAAaG,KAAI,SAAC2E,GAAD,OAAY,EAAK/E,MAAM8E,EAAWC,MACjE,OAAO,IAAIC,EAAa,MAAOH,EAAU7E,K,oBAG7C,SAAOiF,GAAc,IAAD,OACVjF,EAAQC,EAAaG,KAAI,SAACL,GAAD,OAAS,EAAKC,MHhC5B,EGgCmCD,EAAmBkF,MACvE,OAAO,IAAID,EAAa,SAAUC,EAAajF,K,oBAGnD,SAAOkF,GAAc,IAAD,OACVnD,EAAYF,KAAKC,MAAMoD,EHlCV,GGmCbC,EAAYD,EHnCC,EGqCblF,EAAQG,EAAemE,SAAQ,SAACc,GAClC,IAAMrF,EHtCS,EGsCFgC,EAA2BqD,EACxC,OAAOjF,EAAeC,KAAI,SAACiF,GACvB,IACMvE,EH5CG,EG4CMf,GHzCJ,EGwCEoF,EAA2BE,GAExC,OAAO,EAAKrF,MAAMc,SAG1B,OAAO,IAAIkE,EAAa,SAAUE,EAAalF,K,qBAGnD,SAAQiC,EAAae,GACjB,OAAQf,GACJ,IAAK,MACD,OAAOd,KAAKpB,IAAIiD,GACpB,IAAK,SACD,OAAO7B,KAAKG,OAAO0B,GACvB,IAAK,SACD,OAAO7B,KAAKI,OAAOyB,GACvB,QACI,MAAM,IAAI5B,MAAJ,gCAAmCa,EAAnC,U,sBApElB,SAAeuC,GACX,IADuB,EACnBhC,EAAO,IAAII,EACT5C,EAAQwC,EAAK8C,WAAWd,GAFP,cAIJxE,GAJI,IAIvB,2BAA0B,CAAC,IAAhBqD,EAAe,QACjB5B,MAAM4B,EAAKtC,SACZyB,EAAOD,EAAYC,EAAM,IAAIF,EAAee,EAAKvC,MAAOuC,EAAKtC,OAAO,MANrD,8BASvB,OAAOyB,M,KAgETwC,E,WACF,WAAYZ,EAAMtD,EAAOd,GAAQ,oBAC7BmB,KAAKiD,KAAOA,EACZjD,KAAKL,MAAQA,EACbK,KAAKnB,MAAQA,E,wCAGjB,WACI,OAAOmB,KAAKnB,MACPI,KAAI,SAACiD,GAAD,OAAUA,EAAKtC,SACnB4C,QAAO,SAAC5C,GAAD,OAAYU,MAAMV,Q,iCAGlC,WACI,OAAOI,KAAKoE,uBAAyBpE,KAAKoE,wBACnCpE,KAAKnB,MAAMwF,QAAO,SAACC,EAAKpC,GACvB,GAAI5B,MAAM4B,EAAKtC,OAAQ,CAAC,IAAD,gBACCsC,EAAKnC,iBADN,IACnB,2BAA0C,CAAC,IAAhCH,EAA+B,QACjC0E,EAAI1B,IAAIhD,IACT0E,EAAIC,IAAI3E,EAAO,IAEnB0E,EAAIE,IAAI5E,GAAO6E,KAAKvC,IALL,+BAQvB,OAAOoC,IACR,IAAII,O,8BAGf,SAAiB9E,GACb,OAAOI,KAAK+C,sBAAsBH,IAAIhD,O,KCtHjC+E,EAAkBC,IAAMC,eAAc,SAAAvD,GAAM,OAAI,QAEhDwD,EAAcF,IAAMC,cAAc,IAAIpD,GCFpC,SAASsD,IACpB,IADgC,EAC5BlG,EAAQ,GADoB,cAEdC,GAFc,IAEhC,2BAAgC,CAAC,IAAD,EAArBF,EAAqB,sBACVE,GADU,IAC5B,2BAAgC,CAAC,IACvBU,ELoBO,EKpBIZ,EADW,QAGtBsD,EAAO,cAAC8C,EAAD,CAAyBrF,MAAOH,GAAhBA,GAC7BX,EAAM4F,KAAKvC,IALa,gCAFA,8BAUhC,OAAO,cAAC5D,EAAD,CAAMO,MAAOA,IAGxB,SAASmG,EAAUzG,GACf,IACM2D,EADO+C,qBAAWH,GACNjG,MAAMN,EAAMoB,OAE9B,OAAKW,MAAM4B,EAAKtC,OAQZ,oBAAInB,UAAS,UAAmC,IAA9ByD,EAAKnC,gBAAgBmF,KAAa,OAAS,YAA7D,SACKC,MAAMC,KAAKlD,EAAKnC,iBAAiBsF,OAAOC,KAAK,OAR9CpD,EAAKrC,SACE,oBAAIpB,UAAW,WAAf,SAA4ByD,EAAKtC,QAEjC,6BAAKsC,EAAKtC,QCpBd,SAAS2F,IACpB,IADiC,EAC7B1G,EAAQ,GADqB,cAEfC,GAFe,IAEjC,2BAAgC,CAAC,IAAD,EAArBF,EAAqB,sBACVE,GADU,IAC5B,2BAAgC,CAAC,IACvBU,ENmBO,EMnBIZ,EADW,QAEtBsD,EAAO,cAACsD,EAAD,CAAoB7F,MAAOH,GAAhBA,GACxBX,EAAM4F,KAAKvC,IAJa,gCAFC,8BASjC,OAAO,cAAC5D,EAAD,CAAMO,MAAOA,IAGxB,SAAS2G,EAAKjH,GACV,IAAMkH,EAAWR,qBAAWN,GAEtBzC,EADO+C,qBAAWH,GACNjG,MAAMN,EAAMoB,OAE9B,OAAIuC,EAAKrC,SACE,oBAAIpB,UAAW,WAAf,SAA4ByD,EAAKtC,QAIxC,6BACI,uBACIqD,KAAK,SAASyC,IAAI,IAAIC,IAAI,IAAIC,UAAU,IACxChG,MAAOsC,EAAKtC,MAAQsC,EAAKtC,MAAQ,GACjCiG,SAAU,SAACC,GAAD,OACNL,EAAS,IAAItE,EAAee,EAAKvC,MAAOmG,EAAMC,OAAOC,iBAEzDvH,UAAS,UAAmC,IAA9ByD,EAAKnC,gBAAgBmF,KAAa,OAAS,GAAhD,YAAsDhD,EAAKpC,OAAOO,MAAQ,EAAI,QAAU,Q,MC1BlG,SAAS4F,EAAO1H,GAC3B,MAAyB2H,qBACrB9E,EACA7C,EAAM8E,YACN,SAACA,GAAD,OAAgB5B,EAAU0E,QAAQ9C,MAHtC,mBAAOhC,EAAP,KAAaoE,EAAb,KAMA,OACI,cAACX,EAAYsB,SAAb,CAAsBxG,MAAOyB,EAA7B,SACI,eAACsD,EAAgByB,SAAjB,CAA0BxG,MAAO6F,EAAjC,UACI,qBAAKhH,UAAU,SAAf,SACI,cAAC8G,EAAD,MAEJ,qBAAK9G,UAAU,eAAf,SACI,cAACsG,EAAD,WCXpBsB,IAASC,OACL,eAAC,IAAMC,WAAP,WACI,4BAAG,mBAAGC,KAAK,qCAAqCT,OAAO,SAASU,IAAI,sBAAjE,gCAEH,cAAC,EAAD,CAAQpD,WANG,yFAQfqD,SAASC,eAAe,STkHpB,kBAAmBC,WACnBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GAC/BA,EAAaC,kB","file":"static/js/main.0b291bad.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                        'worker. To learn more, visit https://bit.ly/CRA-PWA',\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl, {\n        headers: {'Service-Worker': 'script'},\n    })\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                'No internet connection found. App is running in offline mode.',\n            );\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","export default function Grid(props) {\n    return (\n        <table>\n            <colgroup span=\"1\"/>\n            <colgroup className=\"region\" span=\"3\"/>\n            <colgroup className=\"region\" span=\"3\"/>\n            <colgroup className=\"region\" span=\"3\"/>\n\n            <HeaderRow/>\n            <tbody className=\"region\">\n            <Row row={0} cells={props.cells}/>\n            <Row row={1} cells={props.cells}/>\n            <Row row={2} cells={props.cells}/>\n            </tbody>\n            <tbody className=\"region\">\n            <Row row={3} cells={props.cells}/>\n            <Row row={4} cells={props.cells}/>\n            <Row row={5} cells={props.cells}/>\n            </tbody>\n            <tbody className=\"region\">\n            <Row row={6} cells={props.cells}/>\n            <Row row={7} cells={props.cells}/>\n            <Row row={8} cells={props.cells}/>\n            </tbody>\n        </table>\n    );\n}\n\nexport const GRID_SIZE = 9;\nexport const GRID_INDEXES = [0, 1, 2, 3, 4, 5, 6, 7, 8];\nexport const SEGMENT_TYPES = ['row', 'column', 'region'];\nexport const REGION_SIZE = 3;\nexport const REGION_INDEXES = [0, 1, 2];\n\nfunction HeaderRow() {\n    return (\n        <thead>\n        <tr>\n            <th>{/* empty row/column header */}</th>\n            {GRID_INDEXES.map((i) =>\n                <th scope=\"col\" key={i}>{i}</th>,\n            )}\n        </tr>\n        </thead>\n    );\n}\n\nfunction Row(props) {\n    const rowLabel = \"ABCDEFGHI\".charAt(props.row);\n    const rowStartIdx = props.row * GRID_SIZE;\n    return (\n        <tr>\n            <th scope=\"row\">{rowLabel}</th>\n            {GRID_INDEXES.map((col) => {\n                const cellIdx = rowStartIdx + col;\n                return props.cells[cellIdx];\n            })}\n        </tr>\n    );\n}\n","import {GRID_SIZE, REGION_SIZE} from \"./Grid\";\n\nconst AVAILABLE_VALUES = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nexport default class CellState {\n    constructor(index, value, readOnly, errors, availableValues) {\n        this.index = index;\n        this.value = value;\n\n        if (readOnly) {\n            this.readOnly = true;\n            if (errors || availableValues) {\n                throw new Error(`readOnly cell should not have errors or availableValues ${errors} or ${availableValues}`);\n            }\n        } else {\n            this.errors = errors !== undefined ? errors : {row: 0, column: 0, region: 0, total: 0};\n            if (isNaN(this.value)) {\n                this.availableValues = availableValues || new Set(AVAILABLE_VALUES);\n            } else {\n                this.availableValues = new Set();\n            }\n        }\n\n        // Object.freeze(this.errors);\n        // Object.freeze(this.availableValues);\n        Object.freeze(this);\n    }\n\n    get row() {\n        return Math.trunc(this.index / GRID_SIZE);\n    }\n\n    get column() {\n        return this.index % GRID_SIZE;\n    }\n\n    get regionRow() {\n        return Math.trunc(this.row / REGION_SIZE);\n    }\n\n    get regionColumn() {\n        return Math.trunc(this.column / REGION_SIZE);\n    }\n\n    get region() {\n        return (this.regionRow * REGION_SIZE) + this.regionColumn;\n    }\n\n    setError(segmentType) {\n        if (this.errors[segmentType]) {\n            throw new Error(`Error has already been set for segment type ${segmentType}`);\n        }\n        this.errors[segmentType] = 1;\n        this.errors.total += 1;\n    }\n\n    clearError(segmentType) {\n        if (!this.errors[segmentType]) {\n            throw new Error(`Error is not set for segment type ${segmentType}`);\n        }\n        this.errors[segmentType] = 0;\n        this.errors.total -= 1;\n    }\n\n    setAvailableValue(value) {\n        this.availableValues.clear();\n        this.availableValues.add(value);\n    }\n\n    addAvailableValue(value) {\n        this.availableValues.add(value);\n    }\n\n    removeAvailableValues(values) {\n        for (const value of values) {\n            this.availableValues.delete(value);\n        }\n    }\n}\n","import GridState from './GridState';\nimport CellState from './CellState';\nimport {SEGMENT_TYPES} from \"./Grid\";\n\nexport function SetValueAction(index, value, readOnly) {\n    this.index = index;\n    this.value = value;\n    this.readOnly = readOnly || false;\n}\n\nexport function gridReducer(grid, action) {\n    if (action.constructor !== SetValueAction) {\n        throw new Error(`Invalid action ${action}`);\n    }\n\n    // Don't change anything if the action is invalid\n    if (action.value < 1 || action.value > 9) {\n        return grid;\n    }\n\n    if (!isNaN(action.value)) {\n        return setCellValue(grid, action);\n    } else {\n        return clearCellValue(grid, action);\n    }\n}\n\nfunction setCellValue(grid, action) {\n    // Clone the cells array before modifying it\n    const cells = [...grid.cells];\n    const newGrid = new GridState(cells);\n\n    // Update the cell according to the action\n    const oldCell = cells[action.index];\n    const newCell = cells[action.index] = cellReducer(oldCell, action);\n\n    for (const segmentType of SEGMENT_TYPES) {\n        const segmentIndex = newCell[segmentType];\n        const segment = newGrid.segment(segmentType, segmentIndex);\n\n        // Update the availableValues of related cells by removing this used value\n        for (const cell of segment.cells) {\n            if (isNaN(cell.value) && cell.availableValues.has(action.value)) {\n                cell.removeAvailableValues([action.value]);\n            }\n        }\n        eliminateAvailableValues(segment);\n\n        // Mark any errors if this new value has caused any\n        const valueCells = segment.cells\n            .filter((cell) => cell.value === action.value);\n        if (valueCells.length > 1) {\n            for (const cell of valueCells) {\n                if (!cell.readOnly && !cell.errors[segmentType]) {\n                    cell.setError(segmentType);\n                }\n            }\n        }\n    }\n    return newGrid;\n}\n\nfunction clearCellValue(grid, action) {\n    // Clone the cells array before modifying it\n    const cells = [...grid.cells];\n    const newGrid = new GridState(cells);\n\n    // Update the cell according to the action\n    const oldCell = cells[action.index];\n    const newCell = cells[action.index] = cellReducer(oldCell, action);\n\n    for (const segmentType of SEGMENT_TYPES) {\n        const segmentIndex = newCell[segmentType];\n        const segment = newGrid.segment(segmentType, segmentIndex);\n\n        // Re-calculate the availableValues for the cell that has been cleared\n        const usedValues = segment.values;\n        newCell.removeAvailableValues(usedValues);\n        // Add old value back to availableValues of related cells\n        relatedCell:\n            for (const cell of segment.cells) {\n                if (cell.readOnly) {\n                    continue;\n                }\n                for (const segmentType1 of SEGMENT_TYPES) {\n                    const segment1 = newGrid.segment(segmentType1, cell[segmentType1]);\n                    if (!segment1.isValueAvailable(oldCell.value)) {\n                        continue relatedCell;\n                    }\n                }\n                cell.addAvailableValue(oldCell.value);\n            }\n        eliminateAvailableValues(segment);\n\n        // Clear errors in related cells that have been resolved by clearing this cell\n        const valueCells = segment.cells\n            .filter((cell) => cell.value === oldCell.value);\n        if (valueCells.length === 1) { // More than 1 means it is still an error\n            for (const cell of valueCells) {\n                if (!cell.readOnly && cell.errors[segmentType]) {\n                    cell.clearError(segmentType);\n                }\n            }\n        }\n    }\n    return new GridState(cells);\n}\n\nfunction eliminateAvailableValues(segment) {\n    // Detect values that are available in one cell only\n    for (const [value, cells] of segment.cellsByAvailableValue) {\n        if (cells.length === 1) {\n            cells[0].setAvailableValue(value);\n        }\n    }\n}\n\nfunction cellReducer(cell, action) {\n    // console.log(cell, action);\n    if (cell.readOnly) {\n        throw new Error(`Attempted to modify readOnly cell ${cell.index}`);\n    }\n\n    if (action.constructor === SetValueAction) {\n        const readOnly = action.readOnly; // true during init()\n        const errors = !readOnly && !isNaN(action.value) ? cell.errors : undefined;\n        return new CellState(action.index, action.value, readOnly, errors);\n        // We will update the error value separately\n    } else {\n        throw new Error(`Unknown action type ${action.type}`);\n    }\n}\n","import CellState from './CellState';\nimport {gridReducer, SetValueAction} from './gridReducer';\nimport {GRID_INDEXES, GRID_SIZE, REGION_INDEXES, REGION_SIZE} from \"./Grid\";\n\nexport default class GridState {\n    constructor(cells) {\n        if (!cells) {\n            this.cells = this._emptyGrid();\n        } else {\n            this.cells = cells;\n        }\n\n        if (this.cells.length !== GRID_SIZE ** 2) {\n            throw new Error(`Grid must contain 81 cells: got ${cells.length}`);\n        }\n\n        // Object.freeze(this.cells);\n        Object.freeze(this);\n    }\n\n    static newFrom(gridString) {\n        let grid = new GridState();\n        const cells = grid._parseGrid(gridString);\n        // Add each cell incrementally so the availableValues can be kept up-to-date\n        for (const cell of cells) {\n            if (!isNaN(cell.value)) {\n                grid = gridReducer(grid, new SetValueAction(cell.index, cell.value, true));\n            }\n        }\n        return grid;\n    }\n\n    _emptyGrid() {\n        let i = 0;\n        return GRID_INDEXES.flatMap(() =>\n            GRID_INDEXES.map(() =>\n                new CellState(i++, NaN)\n            )\n        );\n    }\n\n    _parseGrid(gridString) {\n        const values = (gridString).split('');\n        return values.map((val, idx) => {\n            if (!val || val < 1) {\n                val = NaN;\n            } else {\n                val = parseInt(val);\n            }\n            return new CellState(idx, val, !isNaN(val));\n        });\n    }\n\n    row(rowIndex) {\n        const startIdx = rowIndex * GRID_SIZE;\n        const cells = GRID_INDEXES.map((offset) => this.cells[startIdx + offset]);\n        return new SegmentState('row', rowIndex, cells);\n    }\n\n    column(columnIndex) {\n        const cells = GRID_INDEXES.map((row) => this.cells[(row * GRID_SIZE) + columnIndex]);\n        return new SegmentState('column', columnIndex, cells);\n    }\n\n    region(regionIndex) {\n        const regionRow = Math.trunc(regionIndex / REGION_SIZE);\n        const regionCol = regionIndex % REGION_SIZE;\n\n        const cells = REGION_INDEXES.flatMap((rowOffset) => {\n            const row = (regionRow * REGION_SIZE) + rowOffset;\n            return REGION_INDEXES.map((colOffset) => {\n                const col = (regionCol * REGION_SIZE) + colOffset;\n                const index = (row * GRID_SIZE) + col;\n                return this.cells[index];\n            });\n        });\n        return new SegmentState('region', regionIndex, cells);\n    }\n\n    segment(segmentType, segmentIndex) {\n        switch (segmentType) {\n            case 'row':\n                return this.row(segmentIndex);\n            case 'column':\n                return this.column(segmentIndex);\n            case 'region':\n                return this.region(segmentIndex);\n            default:\n                throw new Error(`Unknown segment type '${segmentType}'`);\n        }\n    }\n}\n\nclass SegmentState {\n    constructor(type, index, cells) {\n        this.type = type;\n        this.index = index;\n        this.cells = cells;\n    }\n\n    get values() {\n        return this.cells\n            .map((cell) => cell.value)\n            .filter((value) => !isNaN(value));\n    }\n\n    get cellsByAvailableValue() {\n        return this._cellsByAvailableValue = this._cellsByAvailableValue\n            || this.cells.reduce((acc, cell) => {\n                if (isNaN(cell.value)) {\n                    for (const value of cell.availableValues) {\n                        if (!acc.has(value)) {\n                            acc.set(value, []);\n                        }\n                        acc.get(value).push(cell);\n                    }\n                }\n                return acc;\n            }, new Map());\n    }\n\n    isValueAvailable(value) {\n        return this.cellsByAvailableValue.has(value);\n    }\n}\n","import React from \"react\";\nimport GridState from \"./GridState\";\n\n// noinspection JSUnusedLocalSymbols\nexport const DispatchContext = React.createContext(action => null);\n\nexport const GridContext = React.createContext(new GridState());\n","import React, {useContext} from \"react\";\nimport {GridContext} from \"./Context\";\nimport Grid, {GRID_INDEXES, GRID_SIZE} from \"./Grid\";\n\nexport default function DebugGrid() {\n    let cells = [];\n    for (const row of GRID_INDEXES) {\n        for (const col of GRID_INDEXES) {\n            const cellIdx = (row * GRID_SIZE) + col;\n            // console.log(\"index = \", row, col, GRID_SIZE, cellIdx);\n            const cell = <DebugCell key={cellIdx} index={cellIdx}/>;\n            cells.push(cell);\n        }\n    }\n    return <Grid cells={cells}/>;\n}\n\nfunction DebugCell(props) {\n    const grid = useContext(GridContext);\n    const cell = grid.cells[props.index];\n\n    if (!isNaN(cell.value)) {\n        if (cell.readOnly) {\n            return <td className={'readonly'}>{cell.value}</td>;\n        } else {\n            return <td>{cell.value}</td>;\n        }\n    }\n    return (\n        <td className={`${cell.availableValues.size === 1 ? 'hint' : 'unsolved'}`}>\n            {Array.from(cell.availableValues).sort().join(' ')}\n        </td>\n    );\n}\n","import {useContext} from \"react\";\nimport {DispatchContext, GridContext} from \"./Context\";\nimport Grid, {GRID_INDEXES, GRID_SIZE} from \"./Grid\";\nimport {SetValueAction} from \"./gridReducer\";\n\nexport default function PuzzleGrid() {\n    let cells = [];\n    for (const row of GRID_INDEXES) {\n        for (const col of GRID_INDEXES) {\n            const cellIdx = (row * GRID_SIZE) + col;\n            const cell = <Cell key={cellIdx} index={cellIdx}/>;\n            cells.push(cell);\n        }\n    }\n    return <Grid cells={cells}/>;\n}\n\nfunction Cell(props) {\n    const dispatch = useContext(DispatchContext);\n    const grid = useContext(GridContext);\n    const cell = grid.cells[props.index];\n\n    if (cell.readOnly) {\n        return <td className={'readonly'}>{cell.value}</td>;\n    }\n\n    return (\n        <td>\n            <input\n                type=\"number\" min=\"1\" max=\"9\" maxLength=\"1\"\n                value={cell.value ? cell.value : ''}\n                onChange={(event) => (\n                    dispatch(new SetValueAction(cell.index, event.target.valueAsNumber))\n                )}\n                className={`${cell.availableValues.size === 1 ? 'hint' : ''} ${cell.errors.total > 0 ? 'error' : ''}`}\n            />\n        </td>\n    );\n}\n","import React, {useReducer} from 'react';\nimport {DispatchContext, GridContext} from './Context';\nimport DebugGrid from './DebugGrid';\nimport PuzzleGrid from './PuzzleGrid';\nimport GridState from './GridState';\nimport {gridReducer} from './gridReducer';\nimport './Sudoku.css';\n\nexport default function Sudoku(props) {\n    const [grid, dispatch] = useReducer(\n        gridReducer,\n        props.gridString,\n        (gridString) => GridState.newFrom(gridString),\n    );\n\n    return (\n        <GridContext.Provider value={grid}>\n            <DispatchContext.Provider value={dispatch}>\n                <div className=\"sudoku\">\n                    <PuzzleGrid/>\n                </div>\n                <div className='sudoku debug'>\n                    <DebugGrid />\n                </div>\n            </DispatchContext.Provider>\n        </GridContext.Provider>\n    );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\nimport Sudoku from './sudoku/Sudoku';\n\n// const gridString = '000483276600102580020000100006007000130809047000600900008000060057201008469578000'; // easy\n// const gridString = '070001000005009003103074000608000030901000207020000908000950602400300500000700080'; // medium\n// const gridString = '000090008000000010413706002004900003090040050600008400800509741020000000500010000'; // hard\nconst gridString = '000000080005073090000900300000200709900136004403009000001005000060840900070000000'; // evil\n\nReactDOM.render(\n    <React.StrictMode>\n        <p><a href=\"https://github.com/stevenl/sudoku/\" target=\"_blank\" rel=\"noopener noreferrer\">Source on GitHub</a>\n        </p>\n        <Sudoku gridString={gridString}/>\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}