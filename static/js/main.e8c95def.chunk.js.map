{"version":3,"sources":["serviceWorker.js","sudoku/gridReducer.js","sudoku/grid.js","sudoku/Sudoku.js","index.js"],"names":["Boolean","window","location","hostname","match","SetValueAction","index","value","readOnly","this","gridReducer","grid","action","constructor","Error","isNaN","cells","newGrid","GridState","oldCell","newCell","cellReducer","SEGMENT_TYPES","segmentType","segmentIndex","segment","usedValues","values","removeAvailableValues","relatedCell","cell","segmentType1","isValueAvailable","addAvailableValue","eliminateAvailableValues","valueCells","filter","length","errors","clearError","clearCellValue","availableValues","has","setError","setCellValue","cellsByAvailableValue","setAvailableValue","undefined","CellState","type","GRID_INDEXES","REGION_INDEXES","AVAILABLE_VALUES","_emptyGrid","Object","freeze","gridString","_parseGrid","i","flatMap","map","NaN","split","val","idx","parseInt","rowIndex","startIdx","offset","SegmentState","columnIndex","row","regionIndex","regionRow","Math","trunc","regionCol","rowOffset","colOffset","column","region","_cellsByAvailableValue","reduce","acc","set","get","push","Map","total","Set","regionColumn","clear","add","delete","GridContext","React","createContext","DispatchContext","Sudoku","props","useReducer","init","dispatch","Provider","className","Grid","DebugGrid","span","HeaderRow","Row","rowLabel","charAt","scope","cellIdx","Cell","useContext","min","max","maxLength","onChange","event","target","valueAsNumber","size","DebugRow","DebugCell","Array","from","sort","join","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e8c95def.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                        'worker. To learn more, visit https://bit.ly/CRA-PWA',\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl, {\n        headers: {'Service-Worker': 'script'},\n    })\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                'No internet connection found. App is running in offline mode.',\n            );\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import {CellState, GridState, SEGMENT_TYPES} from './grid';\n\nexport function SetValueAction(index, value, readOnly) {\n    this.index = index;\n    this.value = value;\n    this.readOnly = readOnly || false;\n}\n\nexport function gridReducer(grid, action) {\n    if (action.constructor !== SetValueAction) {\n        throw new Error(`Invalid action ${action}`);\n    }\n\n    // Don't change anything if the action is invalid\n    if (action.value < 1 || action.value > 9) {\n        return grid;\n    }\n\n    if (!isNaN(action.value)) {\n        return setCellValue(grid, action);\n    } else {\n        return clearCellValue(grid, action);\n    }\n}\n\nfunction setCellValue(grid, action) {\n    // Clone the cells array before modifying it\n    const cells = [...grid.cells];\n    const newGrid = new GridState(cells);\n\n    // Update the cell according to the action\n    const oldCell = cells[action.index];\n    const newCell = cells[action.index] = cellReducer(oldCell, action);\n\n    for (const segmentType of SEGMENT_TYPES) {\n        const segmentIndex = newCell[segmentType];\n        const segment = newGrid.segment(segmentType, segmentIndex);\n\n        // Update the availableValues of related cells by removing this used value\n        for (const cell of segment.cells) {\n            if (isNaN(cell.value) && cell.availableValues.has(action.value)) {\n                cell.removeAvailableValues([action.value]);\n            }\n        }\n        eliminateAvailableValues(segment);\n\n        // Mark any errors if this new value has caused any\n        const valueCells = segment.cells\n            .filter((cell) => cell.value === action.value);\n        if (valueCells.length > 1) {\n            for (const cell of valueCells) {\n                if (!cell.readOnly && !cell.errors[segmentType]) {\n                    cell.setError(segmentType);\n                }\n            }\n        }\n    }\n    return newGrid;\n}\n\nfunction clearCellValue(grid, action) {\n    // Clone the cells array before modifying it\n    const cells = [...grid.cells];\n    const newGrid = new GridState(cells);\n\n    // Update the cell according to the action\n    const oldCell = cells[action.index];\n    const newCell = cells[action.index] = cellReducer(oldCell, action);\n\n    for (const segmentType of SEGMENT_TYPES) {\n        const segmentIndex = newCell[segmentType];\n        const segment = newGrid.segment(segmentType, segmentIndex);\n\n        // Re-calculate the availableValues for the cell that has been cleared\n        const usedValues = segment.values;\n        newCell.removeAvailableValues(usedValues);\n        // Add old value back to availableValues of related cells\n        relatedCell:\n            for (const cell of segment.cells) {\n                if (cell.readOnly) {\n                    continue;\n                }\n                for (const segmentType1 of SEGMENT_TYPES) {\n                    const segment1 = newGrid.segment(segmentType1, cell[segmentType1]);\n                    if (!segment1.isValueAvailable(oldCell.value)) {\n                        continue relatedCell;\n                    }\n                }\n                cell.addAvailableValue(oldCell.value);\n            }\n        eliminateAvailableValues(segment);\n\n        // Clear errors in related cells that have been resolved by clearing this cell\n        const valueCells = segment.cells\n            .filter((cell) => cell.value === oldCell.value);\n        if (valueCells.length === 1) { // More than 1 means it is still an error\n            for (const cell of valueCells) {\n                if (!cell.readOnly && cell.errors[segmentType]) {\n                    cell.clearError(segmentType);\n                }\n            }\n        }\n    }\n    return new GridState(cells);\n}\n\nfunction eliminateAvailableValues(segment) {\n    // Detect values that are available in one cell only\n    for (const [value, cells] of segment.cellsByAvailableValue) {\n        if (cells.length === 1) {\n            cells[0].setAvailableValue(value);\n        }\n    }\n}\n\nfunction cellReducer(cell, action) {\n    // console.log(cell, action);\n    if (cell.readOnly) {\n        throw new Error(`Attempted to modify readOnly cell ${cell.index}`);\n    }\n\n    if (action.constructor === SetValueAction) {\n        const readOnly = action.readOnly; // true during init()\n        const errors = !readOnly && !isNaN(action.value) ? cell.errors : undefined;\n        return new CellState(action.index, action.value, readOnly, errors);\n        // We will update the error value separately\n    } else {\n        throw new Error(`Unknown action type ${action.type}`);\n    }\n}\n","import {gridReducer, SetValueAction} from './gridReducer';\n\nexport const GRID_SIZE = 9;\nexport const GRID_INDEXES = [0, 1, 2, 3, 4, 5, 6, 7, 8];\nexport const SEGMENT_TYPES = ['row', 'column', 'region'];\nconst REGION_SIZE = 3;\nconst REGION_INDEXES = [0, 1, 2];\nconst AVAILABLE_VALUES = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nexport class GridState {\n    constructor(cells) {\n        if (!cells) {\n            this.cells = this._emptyGrid();\n        } else {\n            this.cells = cells;\n        }\n\n        if (this.cells.length !== GRID_SIZE ** 2) {\n            throw new Error(`Grid must contain 81 cells: got ${cells.length}`);\n        }\n\n        // Object.freeze(this.cells);\n        Object.freeze(this);\n    }\n\n    init(gridString) {\n        let grid = this;\n        const cells = this._parseGrid(gridString);\n        // Add each cell incrementally so the availableValues can be kept up-to-date\n        for (const cell of cells) {\n            if (!isNaN(cell.value)) {\n                grid = gridReducer(grid, new SetValueAction(cell.index, cell.value, true));\n            }\n        }\n        return grid;\n    }\n\n    _emptyGrid() {\n        let i = 0;\n        return GRID_INDEXES.flatMap(() =>\n            GRID_INDEXES.map(() =>\n                new CellState(i++, NaN)\n            )\n        );\n    }\n\n    _parseGrid(gridString) {\n        const values = (gridString).split('');\n        return values.map((val, idx) => {\n            if (!val || val < 1) {\n                val = NaN;\n            } else {\n                val = parseInt(val);\n            }\n            return new CellState(idx, val, !isNaN(val));\n        });\n    }\n\n    row(rowIndex) {\n        const startIdx = rowIndex * GRID_SIZE;\n        const cells = GRID_INDEXES.map((offset) => this.cells[startIdx + offset]);\n        return new SegmentState('row', rowIndex, cells);\n    }\n\n    column(columnIndex) {\n        const cells = GRID_INDEXES.map((row) => this.cells[(row * GRID_SIZE) + columnIndex]);\n        return new SegmentState('column', columnIndex, cells);\n    }\n\n    region(regionIndex) {\n        const regionRow = Math.trunc(regionIndex / REGION_SIZE);\n        const regionCol = regionIndex % REGION_SIZE;\n\n        const cells = REGION_INDEXES.flatMap((rowOffset) => {\n            const row = (regionRow * REGION_SIZE) + rowOffset;\n            return REGION_INDEXES.map((colOffset) => {\n                const col = (regionCol * REGION_SIZE) + colOffset;\n                const index = (row * GRID_SIZE) + col;\n                return this.cells[index];\n            });\n        });\n        return new SegmentState('region', regionIndex, cells);\n    }\n\n    segment(segmentType, segmentIndex) {\n        switch (segmentType) {\n            case 'row':\n                return this.row(segmentIndex);\n            case 'column':\n                return this.column(segmentIndex);\n            case 'region':\n                return this.region(segmentIndex);\n            default:\n                throw new Error(`Unknown segment type '${segmentType}'`);\n        }\n    }\n}\n\nclass SegmentState {\n    constructor(type, index, cells) {\n        this.type = type;\n        this.index = index;\n        this.cells = cells;\n    }\n\n    get values() {\n        return this.cells\n            .map((cell) => cell.value)\n            .filter((value) => !isNaN(value));\n    }\n\n    get cellsByAvailableValue() {\n        return this._cellsByAvailableValue = this._cellsByAvailableValue\n            || this.cells.reduce((acc, cell) => {\n                if (isNaN(cell.value)) {\n                    for (const value of cell.availableValues) {\n                        if (!acc.has(value)) {\n                            acc.set(value, []);\n                        }\n                        acc.get(value).push(cell);\n                    }\n                }\n                return acc;\n            }, new Map());\n    }\n\n    isValueAvailable(value) {\n        return this.cellsByAvailableValue.has(value);\n    }\n}\n\nexport class CellState {\n    constructor(index, value, readOnly, errors, availableValues) {\n        this.index = index;\n        this.value = value;\n\n        if (readOnly) {\n            this.readOnly = true;\n            if (errors || availableValues) {\n                throw new Error(`readOnly cell should not have errors or availableValues ${errors} or ${availableValues}`);\n            }\n        } else {\n            this.errors = errors !== undefined ? errors : {row: 0, column: 0, region: 0, total: 0};\n            if (isNaN(this.value)) {\n                this.availableValues = availableValues || new Set(AVAILABLE_VALUES);\n            } else {\n                this.availableValues = new Set();\n            }\n        }\n\n        // Object.freeze(this.errors);\n        // Object.freeze(this.availableValues);\n        Object.freeze(this);\n    }\n\n    get row() {\n        return Math.trunc(this.index / GRID_SIZE);\n    }\n\n    get column() {\n        return this.index % GRID_SIZE;\n    }\n\n    get regionRow() {\n        return Math.trunc(this.row / REGION_SIZE);\n    }\n\n    get regionColumn() {\n        return Math.trunc(this.column / REGION_SIZE);\n    }\n\n    get region() {\n        return (this.regionRow * REGION_SIZE) + this.regionColumn;\n    }\n\n    setError(segmentType) {\n        if (this.errors[segmentType]) {\n            throw new Error(`Error has already been set for segment type ${segmentType}`);\n        }\n        this.errors[segmentType] = 1;\n        this.errors.total += 1;\n    }\n\n    clearError(segmentType) {\n        if (!this.errors[segmentType]) {\n            throw new Error(`Error is not set for segment type ${segmentType}`);\n        }\n        this.errors[segmentType] = 0;\n        this.errors.total -= 1;\n    }\n\n    setAvailableValue(value) {\n        this.availableValues.clear();\n        this.availableValues.add(value);\n    }\n\n    addAvailableValue(value) {\n        this.availableValues.add(value);\n    }\n\n    removeAvailableValues(values) {\n        for (const value of values) {\n            this.availableValues.delete(value);\n        }\n    }\n}\n","import React, {useContext, useReducer} from 'react';\nimport {GRID_INDEXES, GRID_SIZE, GridState} from './grid';\nimport {gridReducer, SetValueAction} from './gridReducer';\nimport './Sudoku.css';\n\nconst GridContext = React.createContext(new GridState());\n// noinspection JSUnusedLocalSymbols\nconst DispatchContext = React.createContext(action => null);\n\nexport default function Sudoku(props) {\n    const [grid, dispatch] = useReducer(\n        gridReducer,\n        props.gridString,\n        (gridString) => new GridState().init(gridString),\n    );\n\n    return (\n        <GridContext.Provider value={grid}>\n            <DispatchContext.Provider value={dispatch}>\n                <div className=\"sudoku\">\n                    <Grid />\n                </div>\n                <div className='sudoku debug'>\n                    <DebugGrid />\n                </div>\n            </DispatchContext.Provider>\n        </GridContext.Provider>\n    );\n}\n\nfunction Grid() {\n    return (\n        <table>\n            <colgroup>\n                <col />\n            </colgroup>\n            <colgroup className=\"region\">\n                <col span=\"3\" />\n            </colgroup>\n            <colgroup className=\"region\">\n                <col span=\"3\" />\n            </colgroup>\n            <colgroup className=\"region\">\n                <col span=\"3\" />\n            </colgroup>\n\n            <HeaderRow />\n            <tbody className=\"region\">\n                <Row row={0} />\n                <Row row={1} />\n                <Row row={2} />\n            </tbody>\n            <tbody className=\"region\">\n                <Row row={3} />\n                <Row row={4} />\n                <Row row={5} />\n            </tbody>\n            <tbody className=\"region\">\n                <Row row={6} />\n                <Row row={7} />\n                <Row row={8} />\n            </tbody>\n        </table>\n    );\n}\n\nfunction Row(props) {\n    const rowLabel = \"ABCDEFGHI\".charAt(props.row);\n    const startIdx = props.row * GRID_SIZE;\n    return (\n        <tr>\n            <th scope=\"row\">{rowLabel}</th>\n            {GRID_INDEXES.map((offset) => {\n                const cellIdx = startIdx + offset;\n                return <Cell key={cellIdx} index={cellIdx} />;\n            })}\n        </tr>\n    );\n}\n\nfunction Cell(props) {\n    const dispatch = useContext(DispatchContext);\n    const grid = useContext(GridContext);\n    const cell = grid.cells[props.index];\n\n    if (cell.readOnly) {\n        return <td className={'readonly'}>{cell.value}</td>;\n    }\n\n    return (\n        <td>\n            <input\n                type=\"number\" min=\"1\" max=\"9\" maxLength=\"1\"\n                value={cell.value ? cell.value : ''}\n                onChange={(event) => (\n                    dispatch(new SetValueAction(cell.index, event.target.valueAsNumber))\n                )}\n                className={`${cell.availableValues.size === 1 ? 'hint' : ''} ${cell.errors.total > 0 ? 'error' : ''}`}\n            />\n        </td>\n    );\n}\n\n// Debugger\n\nfunction DebugGrid() {\n    return (\n        <table>\n            <colgroup>\n                <col />\n            </colgroup>\n            <colgroup className=\"region\">\n                <col span=\"3\" />\n            </colgroup>\n            <colgroup className=\"region\">\n                <col span=\"3\" />\n            </colgroup>\n            <colgroup className=\"region\">\n                <col span=\"3\" />\n            </colgroup>\n\n            <HeaderRow />\n            <tbody className=\"region\">\n                <DebugRow row={0} />\n                <DebugRow row={1} />\n                <DebugRow row={2} />\n            </tbody>\n            <tbody className=\"region\">\n                <DebugRow row={3} />\n                <DebugRow row={4} />\n                <DebugRow row={5} />\n            </tbody>\n            <tbody className=\"region\">\n                <DebugRow row={6} />\n                <DebugRow row={7} />\n                <DebugRow row={8} />\n            </tbody>\n        </table>\n    );\n}\n\nfunction HeaderRow() {\n    return (\n        <thead>\n            <tr>\n                <th>{/* empty row/column header */}</th>\n                {GRID_INDEXES.map((i) =>\n                    <th scope=\"col\" key={i}>{i}</th>,\n                )}\n            </tr>\n        </thead>\n    );\n}\n\nfunction DebugRow(props) {\n    const rowLabel = \"ABCDEFGHI\".charAt(props.row);\n    const startIdx = props.row * GRID_SIZE;\n    return (\n        <tr>\n            <th scope=\"row\">{rowLabel}</th>\n            {GRID_INDEXES.map((offset) => {\n                const cellIdx = startIdx + offset;\n                return <DebugCell key={cellIdx} index={cellIdx} />;\n            })}\n        </tr>\n    );\n}\n\nfunction DebugCell(props) {\n    const grid = useContext(GridContext);\n    const cell = grid.cells[props.index];\n\n    if (!isNaN(cell.value)) {\n        if (cell.readOnly) {\n            return <td className={'readonly'}>{cell.value}</td>;\n        } else {\n            return <td>{cell.value}</td>;\n        }\n    }\n    return (\n        <td className={`${cell.availableValues.size === 1 ? 'hint' : 'unsolved'}`}>\n            {Array.from(cell.availableValues).sort().join(' ')}\n        </td>\n    );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\nimport Sudoku from './sudoku/Sudoku';\n\n// const gridString = '000483276600102580020000100006007000130809047000600900008000060057201008469578000'; // easy\n// const gridString = '070001000005009003103074000608000030901000207020000908000950602400300500000700080'; // medium\n// const gridString = '000090008000000010413706002004900003090040050600008400800509741020000000500010000'; // hard\nconst gridString = '000000080005073090000900300000200709900136004403009000001005000060840900070000000'; // evil\n\nReactDOM.render(\n    <React.StrictMode>\n        <Sudoku gridString={gridString} />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}