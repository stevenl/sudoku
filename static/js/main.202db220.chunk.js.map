{"version":3,"sources":["serviceWorker.js","sudoku/Grid.js","sudoku/CellState.js","sudoku/SegmentState.js","sudoku/gridReducer.js","sudoku/GridState.js","sudoku/Context.js","sudoku/DebugGrid.js","sudoku/PuzzleGrid.js","sudoku/Sudoku.js","index.js"],"names":["Boolean","window","location","hostname","match","GRID_INDEXES","SEGMENT_TYPES","REGION_INDEXES","HeaderRow","map","i","scope","Row","row","cells","rowLabel","charAt","rowStartIdx","col","Grid","className","span","AVAILABLE_VALUES","CellState","index","value","readOnly","errors","availableValues","this","assert","undefined","column","region","total","isNaN","Set","Object","freeze","Math","trunc","regionRow","regionColumn","segmentType","Error","SegmentState","type","cell","filter","_cellsByAvailableValue","reduce","acc","has","set","get","push","Map","cellsByAvailableValue","gridCells","segmentIndex","rowIndex","startIdx","offset","columnIndex","regionIndex","regionCol","flatMap","rowOffset","colOffset","SetValueAction","gridReducer","grid","action","constructor","GridState","newCells","newCell","cellReducer","segment","newFrom","segmentCell","cellsReducer","recalculateAvailableValues","clearCell","setCell","refreshCell","delete","_emptyGrid","length","NaN","gridString","split","val","idx","parseInt","_parseGridString","DispatchContext","React","createContext","GridContext","DebugCell","useContext","size","Array","from","sort","join","DebugGrid","cellIdx","Cell","dispatch","min","max","maxLength","onChange","event","target","valueAsNumber","PuzzleGrid","Sudoku","useReducer","Provider","ReactDOM","render","StrictMode","href","rel","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.202db220.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                        'worker. To learn more, visit https://bit.ly/CRA-PWA',\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl, {\n        headers: {'Service-Worker': 'script'},\n    })\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                'No internet connection found. App is running in offline mode.',\n            );\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import PropTypes from \"prop-types\";\n\nfunction Grid({cells, className}) {\n    return (\n        <div className={className}>\n            <table>\n                <colgroup span=\"1\"/>\n                <colgroup className=\"region\" span=\"3\"/>\n                <colgroup className=\"region\" span=\"3\"/>\n                <colgroup className=\"region\" span=\"3\"/>\n\n                <HeaderRow/>\n                <tbody className=\"region\">\n                <Row row={0} cells={cells}/>\n                <Row row={1} cells={cells}/>\n                <Row row={2} cells={cells}/>\n                </tbody>\n                <tbody className=\"region\">\n                <Row row={3} cells={cells}/>\n                <Row row={4} cells={cells}/>\n                <Row row={5} cells={cells}/>\n                </tbody>\n                <tbody className=\"region\">\n                <Row row={6} cells={cells}/>\n                <Row row={7} cells={cells}/>\n                <Row row={8} cells={cells}/>\n                </tbody>\n            </table>\n        </div>\n    );\n}\n\nexport const GRID_SIZE = 9;\nexport const GRID_INDEXES = [0, 1, 2, 3, 4, 5, 6, 7, 8];\nexport const SEGMENT_TYPES = ['row', 'column', 'region'];\nexport const REGION_SIZE = 3;\nexport const REGION_INDEXES = [0, 1, 2];\n\nfunction HeaderRow() {\n    return (\n        <thead>\n        <tr>\n            <th>{/* empty row/column header */}</th>\n            {GRID_INDEXES.map((i) =>\n                <th scope=\"col\" key={i}>{i}</th>,\n            )}\n        </tr>\n        </thead>\n    );\n}\n\nfunction Row({row, cells}) {\n    const rowLabel = \"ABCDEFGHI\".charAt(row);\n    const rowStartIdx = row * GRID_SIZE;\n    return (\n        <tr>\n            <th scope=\"row\">{rowLabel}</th>\n            {GRID_INDEXES.map((col) => {\n                const cellIdx = rowStartIdx + col;\n                return cells[cellIdx];\n            })}\n        </tr>\n    );\n}\n\nGrid.propTypes = {\n    cells: PropTypes.arrayOf(PropTypes.element),\n    className: PropTypes.string,\n};\nRow.propTypes = {\n    row: PropTypes.number,\n    cells: PropTypes.arrayOf(PropTypes.element),\n};\n\nexport default Grid;\n","import assert from \"assert\";\nimport {GRID_SIZE, REGION_SIZE} from \"./Grid\";\n\nexport const AVAILABLE_VALUES = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nexport default class CellState {\n    constructor(index, value, readOnly, errors, availableValues) {\n        this.index = index;\n        this.value = value;\n\n        if (readOnly) {\n            this.readOnly = true;\n            assert(!errors, `readOnly cell should not have errors '${errors}'`);\n            assert(!availableValues, `readOnly cell should not have availableValues '${availableValues}'`);\n        } else {\n            this.errors = errors !== undefined ? errors : {row: 0, column: 0, region: 0, total: 0};\n            if (isNaN(this.value)) {\n                this.availableValues = availableValues || new Set(AVAILABLE_VALUES);\n            } else {\n                this.availableValues = new Set();\n            }\n        }\n\n        Object.freeze(this.errors);\n        Object.freeze(this.availableValues);\n        Object.freeze(this);\n    }\n\n    get row() {\n        return Math.trunc(this.index / GRID_SIZE);\n    }\n\n    get column() {\n        return this.index % GRID_SIZE;\n    }\n\n    get regionRow() {\n        return Math.trunc(this.row / REGION_SIZE);\n    }\n\n    get regionColumn() {\n        return Math.trunc(this.column / REGION_SIZE);\n    }\n\n    get region() {\n        return (this.regionRow * REGION_SIZE) + this.regionColumn;\n    }\n\n    segment(segmentType) {\n        switch (segmentType) {\n            case 'row':\n                return this.row;\n            case 'column':\n                return this.column;\n            case 'region':\n                return this.region;\n            default:\n                throw new Error(`Unknown segment type '${segmentType}'`);\n        }\n    }\n}\n","import {GRID_INDEXES, GRID_SIZE, REGION_INDEXES, REGION_SIZE} from \"./Grid\";\n\nexport default class SegmentState {\n    static newFrom(gridCells, segmentIndex, segmentType) {\n        switch (segmentType) {\n            case 'row':\n                return row(gridCells, segmentIndex);\n            case 'column':\n                return column(gridCells, segmentIndex);\n            case 'region':\n                return region(gridCells, segmentIndex);\n            default:\n                throw new Error(`Unknown segment type '${segmentType}'`);\n        }\n    }\n\n    constructor(type, index, cells) {\n        this.type = type;\n        this.index = index;\n        this.cells = cells;\n    }\n\n    get values() {\n        return this.cells\n            .map((cell) => cell.value)\n            .filter((value) => !isNaN(value));\n    }\n\n    get cellsByAvailableValue() {\n        return this._cellsByAvailableValue = this._cellsByAvailableValue\n            || this.cells.reduce((acc, cell) => {\n                if (isNaN(cell.value)) {\n                    for (const value of cell.availableValues) {\n                        if (!acc.has(value)) {\n                            acc.set(value, []);\n                        }\n                        acc.get(value).push(cell);\n                    }\n                }\n                return acc;\n            }, new Map());\n    }\n\n    isValueAvailable(value) {\n        return this.cellsByAvailableValue.has(value);\n    }\n}\n\nfunction row(gridCells, rowIndex) {\n    const startIdx = rowIndex * GRID_SIZE;\n    const cells = GRID_INDEXES.map((offset) => gridCells[startIdx + offset]);\n    return new SegmentState('row', rowIndex, cells);\n}\n\nfunction column(gridCells, columnIndex) {\n    const cells = GRID_INDEXES.map((row) => gridCells[(row * GRID_SIZE) + columnIndex]);\n    return new SegmentState('column', columnIndex, cells);\n}\n\nfunction region(gridCells, regionIndex) {\n    const regionRow = Math.trunc(regionIndex / REGION_SIZE);\n    const regionCol = regionIndex % REGION_SIZE;\n\n    const cells = REGION_INDEXES.flatMap((rowOffset) => {\n        const row = (regionRow * REGION_SIZE) + rowOffset;\n        return REGION_INDEXES.map((colOffset) => {\n            const col = (regionCol * REGION_SIZE) + colOffset;\n            const index = (row * GRID_SIZE) + col;\n            return gridCells[index];\n        });\n    });\n    return new SegmentState('region', regionIndex, cells);\n}\n","import assert from 'assert';\nimport GridState from './GridState';\nimport SegmentState from './SegmentState';\nimport CellState, {AVAILABLE_VALUES} from './CellState';\nimport {SEGMENT_TYPES} from \"./Grid\";\n\nexport function SetValueAction(index, value, gridCells, readOnly = false) {\n    this.index = index;\n    this.value = value;\n    this.gridCells = gridCells;\n\n    // Used for initialising the grid\n    this.readOnly = readOnly;\n}\n\nexport function gridReducer(grid, action) {\n    assert(action.constructor === SetValueAction,\n        `Invalid action '${action.constructor}'`);\n\n    // Don't change anything if the action is invalid\n    if (action.value < 1 || action.value > 9) {\n        return grid;\n    }\n\n    return new GridState(\n        cellsReducer(grid.cells, action)\n    );\n}\n\nfunction cellsReducer(cells, action) {\n    // Clone the cells array before modifying it\n    const newCells = [...cells];\n\n    // Update the cell according to the action\n    const oldCell = newCells[action.index];\n    const newCell = cellReducer(oldCell, action);\n    newCells[action.index] = newCell;\n\n    // Recalculate availableValues for related cells\n    for (const segmentType of SEGMENT_TYPES) {\n        const segmentIndex = newCell.segment(segmentType);\n        const segment = SegmentState.newFrom(cells, segmentIndex, segmentType);\n\n        for (const segmentCell of segment.cells) {\n            if (isNaN(segmentCell.value) && segmentCell.index !== action.index) {\n                newCells[segmentCell.index] = cellReducer(segmentCell, action);\n            }\n        }\n    }\n\n    return newCells;\n}\n\nfunction cellReducer(cell, action) {\n    assert(!cell.readOnly, `Should not reduce a readOnly cell '${cell}'`);\n\n    if (cell.index === action.index) {\n        if (isNaN(action.value)) {\n            return clearCell(cell, action);\n        } else {\n            return setCell(cell, action);\n        }\n    } else {\n        assert(isNaN(cell.value), `Should not refresh cell with value '${cell.value}'`);\n        return refreshCell(cell, action);\n    }\n}\n\nfunction setCell(cell, action) {\n    return new CellState(\n        action.index, action.value, action.readOnly,\n        action.readOnly ? undefined : cell.errors, //todo\n        undefined,\n    );\n}\n\nfunction clearCell(cell, action) {\n    return new CellState(\n        action.index, action.value, action.readOnly, undefined,\n        recalculateAvailableValues(cell, action),\n    );\n}\n\nfunction refreshCell(cell, action) {\n    return new CellState(\n        cell.index, cell.value, cell.readOnly, cell.errors,\n        recalculateAvailableValues(cell, action),\n    );\n}\n\nfunction recalculateAvailableValues(cell, action) {\n    const availableValues = new Set(AVAILABLE_VALUES)\n    availableValues.delete(action.value);\n\n    for (const segmentType of SEGMENT_TYPES) {\n        const segmentIndex = cell.segment(segmentType);\n        const segment = SegmentState.newFrom(action.gridCells, segmentIndex, segmentType);\n\n        for (const segmentCell of segment.cells) {\n            // The old value of the cell should not be removed from availableValues\n            if (!isNaN(segmentCell.value) && segmentCell.index !== action.index) {\n                availableValues.delete(segmentCell.value);\n            }\n        }\n    }\n    return availableValues;\n}\n\n// function setCellError(cell, segmentType) {\n//     if (cell.errors[segmentType]) {\n//         throw new Error(`Error has already been set for segment type ${segmentType}`);\n//     }\n//     cell.errors[segmentType] = 1;\n//     cell.errors.total += 1;\n// }\n//\n// function clearCellError(cell, segmentType) {\n//     if (!cell.errors[segmentType]) {\n//         throw new Error(`Error is not set for segment type ${segmentType}`);\n//     }\n//     cell.errors[segmentType] = 0;\n//     cell.errors.total -= 1;\n// }\n","import assert from 'assert';\nimport CellState from './CellState';\nimport {gridReducer, SetValueAction} from './gridReducer';\nimport {GRID_INDEXES, GRID_SIZE} from \"./Grid\";\n\nexport default class GridState {\n    constructor(cells) {\n        if (!cells) {\n            this.cells = this._emptyGrid();\n        } else {\n            this.cells = cells;\n        }\n        assert(this.cells.length === GRID_SIZE ** 2,\n            `Grid has incorrect number of cells '${this.cells.length}'`);\n\n        Object.freeze(this.cells);\n        Object.freeze(this);\n    }\n\n    static newFrom(gridString) {\n        let grid = new GridState();\n        const cells = grid._parseGridString(gridString);\n        // Add each cell incrementally so the availableValues can be kept up-to-date\n        for (const cell of cells) {\n            if (!isNaN(cell.value)) {\n                grid = gridReducer(grid, new SetValueAction(cell.index, cell.value, cells, true));\n            }\n        }\n        return grid;\n    }\n\n    _emptyGrid() {\n        let i = 0;\n        return GRID_INDEXES.flatMap(() =>\n            GRID_INDEXES.map(() =>\n                new CellState(i++, NaN)\n            )\n        );\n    }\n\n    _parseGridString(gridString) {\n        const values = (gridString).split('');\n        return values.map((val, idx) => {\n            if (!val || val < 1) {\n                val = NaN;\n            } else {\n                val = parseInt(val);\n            }\n            return new CellState(idx, val, !isNaN(val));\n        });\n    }\n}\n","import React from \"react\";\nimport GridState from \"./GridState\";\n\n// noinspection JSUnusedLocalSymbols\nexport const DispatchContext = React.createContext(action => null);\n\nexport const GridContext = React.createContext(new GridState());\n","import React, {useContext} from \"react\";\nimport PropTypes from \"prop-types\";\nimport {GridContext} from \"./Context\";\nimport Grid, {GRID_INDEXES, GRID_SIZE} from \"./Grid\";\n\nfunction DebugGrid() {\n    let cells = [];\n    for (const row of GRID_INDEXES) {\n        for (const col of GRID_INDEXES) {\n            const cellIdx = (row * GRID_SIZE) + col;\n            // console.log(\"index = \", row, col, GRID_SIZE, cellIdx);\n            const cell = <DebugCell key={cellIdx} index={cellIdx}/>;\n            cells.push(cell);\n        }\n    }\n    return <Grid className=\"sudoku debug\" cells={cells}/>;\n}\n\nfunction DebugCell({index}) {\n    const grid = useContext(GridContext);\n    const cell = grid.cells[index];\n\n    if (!isNaN(cell.value)) {\n        if (cell.readOnly) {\n            return <td className={'readonly'}>{cell.value}</td>;\n        } else {\n            return <td>{cell.value}</td>;\n        }\n    }\n    return (\n        <td className={`${cell.availableValues.size === 1 ? 'hint' : 'unsolved'}`}>\n            {Array.from(cell.availableValues).sort().join(' ')}\n        </td>\n    );\n}\n\nDebugCell.propTypes = {\n    index: PropTypes.number\n};\n\nexport default DebugGrid;\n","import {useContext} from \"react\";\nimport PropTypes from \"prop-types\";\nimport {DispatchContext, GridContext} from \"./Context\";\nimport Grid, {GRID_INDEXES, GRID_SIZE} from \"./Grid\";\nimport {SetValueAction} from \"./gridReducer\";\n\nfunction PuzzleGrid() {\n    let cells = [];\n    for (const row of GRID_INDEXES) {\n        for (const col of GRID_INDEXES) {\n            const cellIdx = (row * GRID_SIZE) + col;\n            const cell = <Cell key={cellIdx} index={cellIdx}/>;\n            cells.push(cell);\n        }\n    }\n    return <Grid className=\"sudoku\" cells={cells}/>;\n}\n\nfunction Cell({index}) {\n    const dispatch = useContext(DispatchContext);\n    const grid = useContext(GridContext);\n    const cell = grid.cells[index];\n\n    if (cell.readOnly) {\n        return <td className={'readonly'}>{cell.value}</td>;\n    }\n\n    return (\n        <td>\n            <input\n                type=\"number\" min=\"1\" max=\"9\" maxLength=\"1\"\n                value={cell.value ? cell.value : ''}\n                onChange={(event) => (\n                    dispatch(new SetValueAction(cell.index, event.target.valueAsNumber, grid.cells))\n                )}\n                className={`${cell.availableValues.size === 1 ? 'hint' : ''} ${cell.errors.total > 0 ? 'error' : ''}`}\n            />\n        </td>\n    );\n}\n\nCell.propTypes = {\n    index: PropTypes.number\n};\n\nexport default PuzzleGrid;\n","import React, {useReducer} from 'react';\nimport PropTypes from \"prop-types\";\nimport {DispatchContext, GridContext} from './Context';\nimport DebugGrid from './DebugGrid';\nimport PuzzleGrid from './PuzzleGrid';\nimport GridState from './GridState';\nimport {gridReducer} from './gridReducer';\nimport './Sudoku.css';\n\nfunction Sudoku({gridString}) {\n    const [grid, dispatch] = useReducer(\n        gridReducer, gridString, GridState.newFrom\n        // The 3rd arg for lazy initialization prevents repeated calls to\n        // dispatch() on the initial cells\n    );\n\n    return (\n        <GridContext.Provider value={grid}>\n            <DispatchContext.Provider value={dispatch}>\n                <PuzzleGrid/>\n                <DebugGrid/>\n            </DispatchContext.Provider>\n        </GridContext.Provider>\n    );\n}\n\nSudoku.propTypes = {\n    gridString: PropTypes.string\n};\n\nexport default Sudoku;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\nimport Sudoku from './sudoku/Sudoku';\n\n// const gridString = '000483276600102580020000100006007000130809047000600900008000060057201008469578000'; // easy\n// const gridString = '070001000005009003103074000608000030901000207020000908000950602400300500000700080'; // medium\n// const gridString = '000090008000000010413706002004900003090040050600008400800509741020000000500010000'; // hard\nconst gridString = '000000080005073090000900300000200709900136004403009000001005000060840900070000000'; // evil\n\nReactDOM.render(\n    <React.StrictMode>\n        <p><a href=\"https://github.com/stevenl/sudoku/\" target=\"_blank\" rel=\"noopener noreferrer\">Source on GitHub</a>\n        </p>\n        <Sudoku gridString={gridString}/>\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}